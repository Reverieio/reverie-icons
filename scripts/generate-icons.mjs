#!/usr/bin/env node
/**
 * Reverie Icons â€” SVG-to-Code Generator
 *
 * Scans svgs/ for icon folders, parses SVGs, and generates:
 *   - packages/core/src/icons/<name>.ts   (icon definitions)
 *   - packages/core/src/index.ts           (barrel exports)
 *   - packages/core/src/metadata.ts        (search metadata)
 *   - packages/react/src/index.ts          (React components)
 *   - packages/vue/src/index.ts            (Vue components)
 *   - config/icon-metadata.json            (merged metadata)
 *
 * Existing hand-coded icon .ts files are preserved.
 * Only files in svgs/<name>/ trigger code generation.
 * Barrel exports are always regenerated to include ALL icons.
 *
 * Usage:
 *   node scripts/generate-icons.mjs            # full run
 *   node scripts/generate-icons.mjs --dry-run  # preview only
 */

import {
  readFileSync, writeFileSync, existsSync,
  readdirSync, mkdirSync, statSync,
} from 'fs'
import { resolve, join, basename, dirname } from 'path'
import { fileURLToPath } from 'url'

// â”€â”€ Paths & Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const __dirname = dirname(fileURLToPath(import.meta.url))
const ROOT      = resolve(__dirname, '..')

const SVGS_DIR  = resolve(ROOT, 'svgs')
const ICONS_DIR = resolve(ROOT, 'packages/core/src/icons')
const CORE_SRC  = resolve(ROOT, 'packages/core/src')
const REACT_SRC = resolve(ROOT, 'packages/react/src')
const VUE_SRC   = resolve(ROOT, 'packages/vue/src')
const META_JSON = resolve(ROOT, 'config/icon-metadata.json')

const SHAPE_TAGS  = ['path', 'circle', 'rect', 'line', 'polyline', 'polygon', 'ellipse']
const VARIATIONS  = ['outline', 'solid', 'duotone', 'bulk']
const DRY_RUN     = process.argv.includes('--dry-run')

const GENERATED_HEADER = [
  '// @generated â€” DO NOT EDIT MANUALLY',
  '// Generated by scripts/generate-icons.mjs from SVG source files',
  '',
].join('\n')

// â”€â”€ SVG Parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Parse HTML/XML attribute string into { key: value } */
function parseAttrs(str) {
  const attrs = {}
  const re = /([\w-]+)="([^"]*)"/g
  let m
  while ((m = re.exec(str)) !== null) attrs[m[1]] = m[2]
  return attrs
}

/** Extract viewBox from SVG content */
function extractViewBox(content) {
  const m = content.match(/viewBox="([^"]*)"/)
  return m ? m[1] : '0 0 24 24'
}

/** Strip outer <svg> wrapper and XML preamble */
function unwrapSVG(content) {
  return content
    .replace(/<\?xml[^>]*\?>/g, '')
    .replace(/<!--[\s\S]*?-->/g, '')
    .replace(/<svg[^>]*>/i, '')
    .replace(/<\/svg>/i, '')
    .trim()
}

/**
 * Parse SVG content into a flat list of shape elements,
 * tracking inherited group context (opacity, data-color).
 */
function parseElements(content) {
  const inner = unwrapSVG(content)
  const groupStack = []
  const elements = []

  const tagRe = /<(\/?)(\w+)\b([^>]*?)(\/?)\s*>/g
  let match

  while ((match = tagRe.exec(inner)) !== null) {
    const [, closing, tag, attrsStr] = match

    if (tag === 'g') {
      if (closing) {
        groupStack.pop()
      } else {
        groupStack.push(parseAttrs(attrsStr))
      }
    } else if (SHAPE_TAGS.includes(tag) && !closing) {
      const attrs = parseAttrs(attrsStr)
      const groupCtx = groupStack.length > 0 ? groupStack[groupStack.length - 1] : {}

      elements.push({
        tag,
        allAttrs: attrs,
        groupOpacity: groupCtx.opacity ? parseFloat(groupCtx.opacity) : undefined,
        groupDataColor: groupCtx['data-color'] || undefined,
      })
    }
  }

  return elements
}

// â”€â”€ Geometry Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Attributes that describe geometry (not styling) */
const GEO_ATTRS = {
  path:     ['d', 'fill-rule', 'clip-rule'],
  circle:   ['cx', 'cy', 'r'],
  rect:     ['x', 'y', 'width', 'height', 'rx', 'ry'],
  line:     ['x1', 'y1', 'x2', 'y2'],
  polyline: ['points'],
  polygon:  ['points'],
  ellipse:  ['cx', 'cy', 'rx', 'ry'],
}

function extractGeo(tag, allAttrs) {
  const allowed = GEO_ATTRS[tag] || []
  const geo = {}
  for (const key of allowed) {
    if (allAttrs[key] !== undefined) geo[key] = allAttrs[key]
  }
  return geo
}

/** Determine if element is stroked or filled based on SVG attributes */
function getColorMode(attrs) {
  const hasStroke = attrs.stroke && attrs.stroke !== 'none'
  const hasFill   = attrs.fill && attrs.fill !== 'none'
  if (hasFill && !hasStroke) return 'fill'
  if (hasStroke && !hasFill) return 'stroke'
  if (hasFill)               return 'fill'
  return 'stroke' // default for outline icons
}

/** Extract stroke-width from first stroked element, fallback 1.5 */
function extractStrokeWidth(elements) {
  for (const el of elements) {
    if (el.allAttrs['stroke-width']) return parseFloat(el.allAttrs['stroke-width'])
  }
  return 1.5
}

// â”€â”€ Layer Grouping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Group parsed elements into typed layers based on the variation.
 *
 * - outline: force all â†’ single strokeLayer (primary)
 * - solid:   force all â†’ single fillLayer (primary)
 * - duotone/bulk: auto-detect from SVG attributes
 */
function buildLayers(elements, variation) {
  // Outline + Solid: deterministic single layer
  if (variation === 'outline') {
    return [{
      colorMode: 'stroke', opacity: 1, colorSource: 'primary',
      elements: elements.map(el => ({ tag: el.tag, attrs: extractGeo(el.tag, el.allAttrs) })),
    }]
  }
  if (variation === 'solid') {
    return [{
      colorMode: 'fill', opacity: 1, colorSource: 'primary',
      elements: elements.map(el => ({ tag: el.tag, attrs: extractGeo(el.tag, el.allAttrs) })),
    }]
  }

  // Duotone & Bulk: auto-detect layers from SVG attributes
  const layerMap = new Map()

  for (const el of elements) {
    const colorMode = getColorMode(el.allAttrs)
    const opacity   = el.allAttrs.opacity
      ? parseFloat(el.allAttrs.opacity)
      : (el.groupOpacity || 1)

    let colorSource = el.allAttrs['data-color'] || el.groupDataColor || 'primary'

    // Heuristic: in duotone, filled elements with opacity < 1 â†’ secondary
    if (variation === 'duotone' && colorMode === 'fill' && opacity < 1 && colorSource === 'primary') {
      colorSource = 'secondary'
    }

    const key = `${colorMode}|${opacity}|${colorSource}`
    if (!layerMap.has(key)) {
      layerMap.set(key, { colorMode, opacity, colorSource, elements: [] })
    }
    layerMap.get(key).elements.push({ tag: el.tag, attrs: extractGeo(el.tag, el.allAttrs) })
  }

  return [...layerMap.values()]
}

// â”€â”€ Auto-Generation of Missing Variations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * If the designer only provides outline.svg, generate sensible
 * solid / duotone / bulk variations from the outline geometry.
 */
function autoGenerate(outlineLayers) {
  const elements = outlineLayers[0].elements

  return {
    solid: [
      { colorMode: 'fill', opacity: 1, colorSource: 'primary', elements },
    ],
    duotone: [
      { colorMode: 'fill', opacity: 0.2, colorSource: 'secondary', elements },
      { colorMode: 'stroke', opacity: 1, colorSource: 'primary', elements },
    ],
    bulk: [
      { colorMode: 'fill', opacity: 0.15, colorSource: 'primary', elements },
      { colorMode: 'stroke', opacity: 1, colorSource: 'primary', elements },
    ],
  }
}

// â”€â”€ Code Generation: Icon .ts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function elementToCode(el) {
  switch (el.tag) {
    case 'path': {
      const d = (el.attrs.d || '').replace(/'/g, "\\'")
      const extra = {}
      if (el.attrs['fill-rule']) extra['fill-rule'] = el.attrs['fill-rule']
      if (el.attrs['clip-rule']) extra['clip-rule'] = el.attrs['clip-rule']
      const extraStr = Object.keys(extra).length
        ? `, { ${Object.entries(extra).map(([k, v]) => `'${k}': '${v}'`).join(', ')} }`
        : ''
      return `path('${d}'${extraStr})`
    }
    case 'circle':
      return `circle(${el.attrs.cx || 0}, ${el.attrs.cy || 0}, ${el.attrs.r || 0})`
    case 'rect': {
      const extra = {}
      if (el.attrs.rx) extra.rx = el.attrs.rx
      if (el.attrs.ry) extra.ry = el.attrs.ry
      const extraStr = Object.keys(extra).length
        ? `, { ${Object.entries(extra).map(([k, v]) => `${k}: ${v}`).join(', ')} }`
        : ''
      return `rect(${el.attrs.x || 0}, ${el.attrs.y || 0}, ${el.attrs.width || 0}, ${el.attrs.height || 0}${extraStr})`
    }
    case 'line':
      return `line(${el.attrs.x1 || 0}, ${el.attrs.y1 || 0}, ${el.attrs.x2 || 0}, ${el.attrs.y2 || 0})`
    case 'polyline':
      return `polyline('${el.attrs.points || ''}')`
    case 'polygon':
      return `polygon('${el.attrs.points || ''}')`
    case 'ellipse':
      return `ellipse(${el.attrs.cx || 0}, ${el.attrs.cy || 0}, ${el.attrs.rx || 0}, ${el.attrs.ry || 0})`
    default:
      return `path('')`
  }
}

function layerToCode(layer) {
  const elems = layer.elements.map(el => `      ${elementToCode(el)},`).join('\n')
  const fn = layer.colorMode === 'stroke' ? 'strokeLayer' : 'fillLayer'

  const args = [`[\n${elems}\n    ]`]
  if (layer.opacity !== 1 || layer.colorSource !== 'primary') {
    args.push(layer.opacity.toString())
  }
  if (layer.colorSource !== 'primary') {
    args.push(`'${layer.colorSource}'`)
  }

  return `${fn}(${args.join(', ')})`
}

function generateIconTS(name, displayName, variationLayers, strokeWidth) {
  // Collect all builder imports needed
  const usedBuilders = new Set()
  for (const layers of Object.values(variationLayers)) {
    for (const layer of layers) {
      usedBuilders.add(layer.colorMode === 'stroke' ? 'strokeLayer' : 'fillLayer')
      for (const el of layer.elements) {
        usedBuilders.add(el.tag)
      }
    }
  }

  const imports = [...usedBuilders].sort().join(', ')
  const swOpt = strokeWidth !== 1.5 ? `, { defaultStrokeWidth: ${strokeWidth} }` : ''

  let code = GENERATED_HEADER
  code += `import type { IconSet } from '../types'\n`
  code += `import { defineIcon, ${imports} } from '../define'\n\n`
  code += `const ${name}: IconSet = {\n`
  code += `  name: '${name}',\n`
  code += `  displayName: '${displayName}',\n\n`

  for (const variation of VARIATIONS) {
    const layers = variationLayers[variation]
    const layerCode = layers.map(l => `    ${layerToCode(l)},`).join('\n')
    code += `  ${variation}: defineIcon('${name}', '${variation}', [\n${layerCode}\n  ]${swOpt}),\n\n`
  }

  code += `}\n\nexport default ${name}\n`
  return code
}

// â”€â”€ Code Generation: Barrel Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function toPascalCase(str) {
  return str.replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase())
}

function generateCoreIndex(iconNames) {
  let code = GENERATED_HEADER
  code += `\n/**\n * @reverieio/icons-core\n *\n`
  code += ` * Framework-agnostic SVG icon data.\n`
  code += ` * This package contains pure data â€” no framework dependencies.\n */\n\n`

  // Types
  code += `// â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `export type {\n  IconVariation,\n  IconElement,\n  IconLayer,\n  IconDefinition,\n  IconSet,\n  IconMetadata,\n  BaseIconProps,\n} from './types'\n\n`

  // Builders
  code += `// â”€â”€ Builders (for creating custom icons) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `export {\n  path,\n  circle,\n  rect,\n  line,\n  polyline,\n  polygon,\n  ellipse,\n  strokeLayer,\n  fillLayer,\n  defineIcon,\n} from './define'\n\n`

  // Named exports
  code += `// â”€â”€ Icon data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  for (const name of iconNames) {
    code += `export { default as ${name} } from './icons/${name}'\n`
  }
  code += `\n`

  // Registry
  code += `// â”€â”€ Registry (all icons in one map) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `import type { IconSet } from './types'\n\n`
  for (const name of iconNames) {
    code += `import _${name} from './icons/${name}'\n`
  }
  code += `\n/** Complete registry of all icons, keyed by name */\n`
  code += `export const iconRegistry: Record<string, IconSet> = {\n`
  for (const name of iconNames) {
    code += `  ${name}: _${name},\n`
  }
  code += `}\n\n`

  // Helpers
  code += `/** Get an icon set by name (returns undefined if not found) */\n`
  code += `export function getIcon(name: string): IconSet | undefined {\n`
  code += `  return iconRegistry[name]\n`
  code += `}\n\n`
  code += `/** Get a specific variation of an icon */\n`
  code += `export function getIconVariation(name: string, variation: 'outline' | 'solid' | 'duotone' | 'bulk'): import('./types').IconDefinition | undefined {\n`
  code += `  return iconRegistry[name]?.[variation]\n`
  code += `}\n\n`

  // Metadata re-exports
  code += `// â”€â”€ Metadata re-exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `export { iconMetadata, searchIcons, getIconsByCategory, getIconNames, iconCategories } from './metadata'\n`
  code += `export type { IconCategory } from './metadata'\n`

  return code
}

function generateMetadataTS(metadata, categories) {
  let code = GENERATED_HEADER
  code += `\nimport type { IconMetadata } from './types'\n\n`
  code += `/**\n * Searchable metadata for all icons.\n * Used by documentation sites, icon pickers, and search UIs.\n */\n`
  code += `export const iconMetadata: Record<string, IconMetadata> = {\n`

  for (const [name, meta] of Object.entries(metadata)) {
    code += `  ${name}: {\n`
    code += `    name: '${meta.name}',\n`
    code += `    displayName: '${meta.displayName}',\n`
    code += `    description: '${(meta.description || '').replace(/'/g, "\\'")}',\n`
    code += `    tags: [${(meta.tags || []).map(t => `'${t}'`).join(', ')}],\n`
    code += `    category: '${meta.category || 'uncategorized'}',\n`
    code += `    addedIn: '${meta.addedIn || '1.0.0'}',\n`
    code += `  },\n`
  }

  code += `}\n\n`

  // Categories
  code += `/** All icon categories */\n`
  code += `export const iconCategories = [${categories.map(c => `'${c}'`).join(', ')}] as const\n`
  code += `export type IconCategory = (typeof iconCategories)[number]\n\n`

  // Search functions
  code += `/** Search icons by query string (matches name, tags, description) */\n`
  code += `export function searchIcons(query: string): IconMetadata[] {\n`
  code += `  const q = query.toLowerCase().trim()\n`
  code += `  if (!q) return Object.values(iconMetadata)\n`
  code += `  return Object.values(iconMetadata).filter(\n`
  code += `    (m) =>\n`
  code += `      m.name.includes(q) ||\n`
  code += `      m.displayName.toLowerCase().includes(q) ||\n`
  code += `      m.description.toLowerCase().includes(q) ||\n`
  code += `      m.tags.some((t) => t.includes(q))\n`
  code += `  )\n`
  code += `}\n\n`

  code += `/** Get icons by category */\n`
  code += `export function getIconsByCategory(category: string): IconMetadata[] {\n`
  code += `  return Object.values(iconMetadata).filter((m) => m.category === category)\n`
  code += `}\n\n`

  code += `/** Get all icon names */\n`
  code += `export function getIconNames(): string[] {\n`
  code += `  return Object.keys(iconMetadata)\n`
  code += `}\n`

  return code
}

function generateReactIndex(iconNames) {
  let code = GENERATED_HEADER
  code += `\n/**\n * @reverieio/icons-react\n *\n`
  code += ` * React components for the Reverie icon library.\n`
  code += ` * Each icon is available in 4 variations: Outline, Solid, Duotone, Bulk.\n *\n`
  code += ` * @example\n`
  code += ` *   import { FlaskOutline, DropletSolid } from '@reverieio/icons-react'\n`
  code += ` *   <FlaskOutline size={24} color="#6A89A7" />\n *\n`
  code += ` * Dynamic usage:\n`
  code += ` *   import { Icon } from '@reverieio/icons-react'\n`
  code += ` *   <Icon name="flask" variation="duotone" size={24} />\n`
  code += ` */\n\n`

  // Core imports
  code += `import {\n`
  code += iconNames.map(n => `  ${n},`).join('\n')
  code += `\n} from '@reverieio/icons-core'\n\n`

  code += `import { createReactIcon } from './createReactIcon'\n\n`

  // Re-exports
  code += `// â”€â”€ Re-exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `export { createReactIcon, createReactIconSet } from './createReactIcon'\n`
  code += `export type { ReverieIconProps } from './createReactIcon'\n`
  code += `export { default as Icon } from './Icon'\n`
  code += `export type { DynamicIconProps } from './Icon'\n\n`

  code += `// Re-export core utilities for convenience\n`
  code += `export { iconRegistry, getIcon, getIconVariation, searchIcons, iconMetadata, getIconNames } from '@reverieio/icons-core'\n`
  code += `export type { IconVariation, IconSet, IconDefinition, IconMetadata } from '@reverieio/icons-core'\n\n`

  // Icon components
  for (const name of iconNames) {
    const pascal = toPascalCase(name)
    code += `// â”€â”€ ${pascal} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
    for (const v of VARIATIONS) {
      const vPascal = v.charAt(0).toUpperCase() + v.slice(1)
      const padded  = `${pascal}${vPascal}`.padEnd(22)
      code += `export const ${padded} = createReactIcon('${pascal}${vPascal}', ${name}.${v})\n`
    }
    code += `\n`
  }

  return code
}

function generateVueIndex(iconNames) {
  let code = GENERATED_HEADER
  code += `\n/**\n * @reverieio/icons-vue\n *\n`
  code += ` * Vue 3 adapter for the Reverie icon library.\n */\n\n`

  // --- Static rendering logic (never changes) ---
  code += `import { defineComponent, h } from 'vue'\n`
  code += `import type { PropType } from 'vue'\n`
  code += `import type { IconDefinition, IconVariation, IconLayer } from '@reverieio/icons-core'\n`
  code += `import { iconRegistry } from '@reverieio/icons-core'\n\n`

  code += `// â”€â”€ Rendering logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`
  code += `function renderLayer(layer: IconLayer, color: string, secondaryColor: string, strokeWidth: number) {\n`
  code += `  const resolvedColor = layer.colorSource === 'secondary' ? secondaryColor : color\n`
  code += `  const layerProps: Record<string, unknown> = {}\n\n`
  code += `  if (layer.colorMode === 'fill') {\n`
  code += `    layerProps.fill = resolvedColor\n`
  code += `    layerProps.stroke = 'none'\n`
  code += `  } else {\n`
  code += `    layerProps.fill = 'none'\n`
  code += `    layerProps.stroke = resolvedColor\n`
  code += `    layerProps['stroke-width'] = strokeWidth\n`
  code += `    layerProps['stroke-linecap'] = 'round'\n`
  code += `    layerProps['stroke-linejoin'] = 'round'\n`
  code += `  }\n`
  code += `  if (layer.opacity < 1) layerProps.opacity = layer.opacity\n\n`
  code += `  return h('g', {}, layer.elements.map((el) => h(el.tag, { ...el.attrs, ...layerProps })))\n`
  code += `}\n\n`

  // Factory
  code += `// â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`
  code += `export function createVueIcon(displayName: string, definition: IconDefinition) {\n`
  code += `  return defineComponent({\n`
  code += `    name: displayName,\n`
  code += `    props: {\n`
  code += `      size: { type: Number, default: definition.defaultSize },\n`
  code += `      color: { type: String, default: 'currentColor' },\n`
  code += `      secondaryColor: { type: String, default: undefined },\n`
  code += `      secondaryOpacity: { type: Number, default: undefined },\n`
  code += `      strokeWidth: { type: Number, default: definition.defaultStrokeWidth },\n`
  code += `      title: { type: String, default: undefined },\n`
  code += `    },\n`
  code += `    setup(props) {\n`
  code += `      return () => {\n`
  code += `        const secColor = props.secondaryColor ?? props.color\n`
  code += `        const layers = props.secondaryOpacity != null\n`
  code += `          ? definition.layers.map((l) =>\n`
  code += `              l.colorSource === 'secondary' ? { ...l, opacity: props.secondaryOpacity! } : l\n`
  code += `            )\n`
  code += `          : definition.layers\n\n`
  code += `        return h(\n`
  code += `          'svg',\n`
  code += `          {\n`
  code += `            xmlns: 'http://www.w3.org/2000/svg',\n`
  code += `            width: props.size,\n`
  code += `            height: props.size,\n`
  code += `            viewBox: definition.viewBox,\n`
  code += `            fill: 'none',\n`
  code += `            class: \`reverie-icon reverie-icon-\${definition.variation}\`,\n`
  code += `            style: { flexShrink: 0 },\n`
  code += `            role: props.title ? 'img' : 'presentation',\n`
  code += `            'aria-hidden': props.title ? undefined : true,\n`
  code += `          },\n`
  code += `          [\n`
  code += `            props.title ? h('title', {}, props.title) : null,\n`
  code += `            ...layers.map((layer) => renderLayer(layer, props.color, secColor, props.strokeWidth)),\n`
  code += `          ]\n`
  code += `        )\n`
  code += `      }\n`
  code += `    },\n`
  code += `  })\n`
  code += `}\n\n`

  // Dynamic Icon component
  code += `// â”€â”€ Dynamic Icon component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`
  code += `export const Icon = defineComponent({\n`
  code += `  name: 'ReverieIcon',\n`
  code += `  props: {\n`
  code += `    name: { type: String, required: true },\n`
  code += `    variation: { type: String as PropType<IconVariation>, default: 'outline' },\n`
  code += `    size: { type: Number, default: 24 },\n`
  code += `    color: { type: String, default: 'currentColor' },\n`
  code += `    secondaryColor: { type: String, default: undefined },\n`
  code += `    secondaryOpacity: { type: Number, default: undefined },\n`
  code += `    strokeWidth: { type: Number, default: 1.5 },\n`
  code += `    title: { type: String, default: undefined },\n`
  code += `  },\n`
  code += `  setup(props) {\n`
  code += `    return () => {\n`
  code += `      const iconSet = iconRegistry[props.name]\n`
  code += `      if (!iconSet) return null\n`
  code += `      const def = iconSet[props.variation]\n`
  code += `      const Component = createVueIcon(\n`
  code += `        \`\${iconSet.displayName}\${props.variation.charAt(0).toUpperCase() + props.variation.slice(1)}\`,\n`
  code += `        def\n`
  code += `      )\n`
  code += `      return h(Component, {\n`
  code += `        size: props.size,\n`
  code += `        color: props.color,\n`
  code += `        secondaryColor: props.secondaryColor,\n`
  code += `        secondaryOpacity: props.secondaryOpacity,\n`
  code += `        strokeWidth: props.strokeWidth,\n`
  code += `        title: props.title,\n`
  code += `      })\n`
  code += `    }\n`
  code += `  },\n`
  code += `})\n\n`

  // --- Generated icon component exports ---
  code += `// â”€â”€ Pre-built icon components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`
  code += `import { ${iconNames.join(', ')} } from '@reverieio/icons-core'\n\n`

  for (const name of iconNames) {
    const pascal = toPascalCase(name)
    for (const v of VARIATIONS) {
      const vPascal = v.charAt(0).toUpperCase() + v.slice(1)
      code += `export const ${pascal}${vPascal} = createVueIcon('${pascal}${vPascal}', ${name}.${v})\n`
    }
    code += `\n`
  }

  // Re-exports
  code += `// â”€â”€ Re-exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`
  code += `export { iconRegistry, getIcon, searchIcons, iconMetadata, getIconNames } from '@reverieio/icons-core'\n`
  code += `export type { IconVariation, IconSet, IconDefinition, IconMetadata } from '@reverieio/icons-core'\n`

  return code
}

// â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function main() {
  console.log('ðŸŽ¨ Reverie Icons â€” SVG-to-Code Generator\n')
  if (DRY_RUN) console.log('   (dry run â€” no files will be written)\n')

  // 1. Load existing metadata
  let metadata = {}
  if (existsSync(META_JSON)) {
    metadata = JSON.parse(readFileSync(META_JSON, 'utf-8'))
    console.log(`  ðŸ“„ Loaded ${Object.keys(metadata).length} metadata entries from config/icon-metadata.json`)
  }

  // 2. Scan svgs/ for icon folders
  let generatedCount = 0

  if (existsSync(SVGS_DIR)) {
    const folders = readdirSync(SVGS_DIR).filter(f =>
      !f.startsWith('_') && !f.startsWith('.') && statSync(join(SVGS_DIR, f)).isDirectory()
    )

    if (folders.length > 0) {
      console.log(`\n  ðŸ“‚ Found ${folders.length} icon folder(s) in svgs/\n`)
    }

    for (const folder of folders) {
      const iconDir   = join(SVGS_DIR, folder)
      const rawName   = folder.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
      const camelName = rawName.replace(/-([a-z])/g, (_, c) => c.toUpperCase())
      const displayN  = toPascalCase(rawName)

      // Parse available SVGs
      const parsed = {}
      let strokeWidth = 1.5

      for (const variation of VARIATIONS) {
        const svgPath = join(iconDir, `${variation}.svg`)
        if (existsSync(svgPath)) {
          const content  = readFileSync(svgPath, 'utf-8')
          const elements = parseElements(content)
          const viewBox  = extractViewBox(content)
          const layers   = buildLayers(elements, variation)

          if (variation === 'outline') strokeWidth = extractStrokeWidth(elements)

          parsed[variation] = { viewBox, layers }
        }
      }

      if (!parsed.outline) {
        console.log(`  âš ï¸  Skipping ${folder}/ â€” no outline.svg found`)
        continue
      }

      // Auto-generate missing variations from outline
      const auto = autoGenerate(parsed.outline.layers)
      const variationLayers = {}
      for (const v of VARIATIONS) {
        variationLayers[v] = parsed[v] ? parsed[v].layers : auto[v]
      }

      const totalElements = Object.values(variationLayers)
        .flatMap(layers => layers.flatMap(l => l.elements)).length
      const providedSVGs  = VARIATIONS.filter(v => parsed[v]).join(', ')
      const autoSVGs      = VARIATIONS.filter(v => !parsed[v])

      console.log(`  ðŸ“¦ ${camelName} (${displayN})`)
      console.log(`     SVGs: ${providedSVGs}`)
      if (autoSVGs.length) console.log(`     Auto: ${autoSVGs.join(', ')}`)
      console.log(`     Elements: ${totalElements}`)

      // Generate TS file
      const tsCode = generateIconTS(camelName, displayN, variationLayers, strokeWidth)

      if (!DRY_RUN) {
        mkdirSync(ICONS_DIR, { recursive: true })
        writeFileSync(join(ICONS_DIR, `${camelName}.ts`), tsCode)
      }
      generatedCount++

      // Update metadata from meta.json or defaults
      const metaPath = join(iconDir, 'meta.json')
      if (existsSync(metaPath)) {
        try {
          const fileMeta = JSON.parse(readFileSync(metaPath, 'utf-8'))
          metadata[camelName] = {
            name: camelName,
            displayName: fileMeta.displayName || displayN,
            description: fileMeta.description || '',
            tags: fileMeta.tags || [],
            category: fileMeta.category || 'uncategorized',
            addedIn: fileMeta.addedIn || '1.0.0',
          }
        } catch (e) {
          console.log(`     âš ï¸  Invalid meta.json â€” using defaults`)
        }
      }
      if (!metadata[camelName]) {
        metadata[camelName] = {
          name: camelName,
          displayName: displayN,
          description: `${displayN} icon`,
          tags: [rawName],
          category: 'uncategorized',
          addedIn: '1.0.0',
        }
      }
    }

    if (generatedCount > 0) {
      console.log(`\n  âœ¨ Generated ${generatedCount} icon(s) from SVG files`)
    } else if (folders.length === 0) {
      console.log(`  â„¹ï¸  No icon folders in svgs/ â€” skipping SVG generation`)
    }
  } else {
    console.log('  â„¹ï¸  No svgs/ directory found â€” skipping SVG generation')
  }

  // 3. Discover ALL icon names (generated + hand-coded)
  const allIconNames = readdirSync(ICONS_DIR)
    .filter(f => f.endsWith('.ts') && !f.startsWith('.') && !f.startsWith('_'))
    .map(f => basename(f, '.ts'))
    .sort()

  console.log(`\n  ðŸ“‹ Total icons: ${allIconNames.length} (${generatedCount} generated, ${allIconNames.length - generatedCount} hand-coded)`)

  // 4. Ensure every icon has metadata
  for (const name of allIconNames) {
    if (!metadata[name]) {
      metadata[name] = {
        name,
        displayName: toPascalCase(name),
        description: `${toPascalCase(name)} icon`,
        tags: [name],
        category: 'uncategorized',
        addedIn: '1.0.0',
      }
    }
  }

  // Remove metadata for deleted icons
  for (const key of Object.keys(metadata)) {
    if (!allIconNames.includes(key)) {
      console.log(`  ðŸ—‘ï¸  Removing stale metadata: ${key}`)
      delete metadata[key]
    }
  }

  // Sort by name
  const sortedMeta = {}
  for (const name of allIconNames) sortedMeta[name] = metadata[name]

  // 5. Extract unique categories
  const categories = [...new Set(Object.values(sortedMeta).map(m => m.category))].sort()

  // 6. Write output files
  console.log(`\n  ðŸ”§ Generating barrel exports...`)

  if (!DRY_RUN) {
    // Metadata JSON
    mkdirSync(dirname(META_JSON), { recursive: true })
    writeFileSync(META_JSON, JSON.stringify(sortedMeta, null, 2) + '\n')
    console.log(`     âœ… config/icon-metadata.json`)

    // Core barrel
    writeFileSync(join(CORE_SRC, 'index.ts'), generateCoreIndex(allIconNames))
    console.log(`     âœ… packages/core/src/index.ts`)

    // Core metadata
    writeFileSync(join(CORE_SRC, 'metadata.ts'), generateMetadataTS(sortedMeta, categories))
    console.log(`     âœ… packages/core/src/metadata.ts`)

    // React barrel
    writeFileSync(join(REACT_SRC, 'index.ts'), generateReactIndex(allIconNames))
    console.log(`     âœ… packages/react/src/index.ts`)

    // Vue barrel
    writeFileSync(join(VUE_SRC, 'index.ts'), generateVueIndex(allIconNames))
    console.log(`     âœ… packages/vue/src/index.ts`)
  } else {
    console.log('     (dry run â€” no files written)')
  }

  console.log(`\nðŸŽ‰ Done! ${allIconNames.length} icons â†’ ${allIconNames.length * 4} components`)
  console.log(`   Categories: ${categories.join(', ')}\n`)
}

main()
